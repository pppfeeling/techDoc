<div class="container">
        <header class="header">
            <h1 class="title">Vite.js 핵심 파헤치기</h1>
            <div class="date" id="currentDateDisplay"></div>
        </header>

        <!-- 챕터 1: Vite가 빠른 이유 -->
        <section id="chapter1" class="full-width">
            <div class="card" style="background: linear-gradient(135deg, rgba(255,255,255,1) 0%, rgba(242,230,61,0.1) 100%);">
                <h2 class="card-title"><span class="step-number">1</span> Vite가 <span class="hand-drawn">빛처럼 빠른 이유</span> ⚡️</h2>
                <p>Vite는 기존의 웹팩(Webpack)과 같은 번들러와는 <span class="keyword">근본적으로 다른 접근 방식</span>을 사용해서 개발 시 놀라운 속도를 경험하게 해줘요. 마치 마법 같지만, 사실은 똑똑한 기술들 덕분이랍니다! 그 핵심 비결을 함께 알아볼까요? 🤔</p>
            </div>

            <div class="triple-grid">
                <div class="card">
                    <h3 class="card-title icon-text"><span class="icon">🐌</span> 전통적인 번들러 (예: Webpack)</h3>
                    <p>개발 서버를 켤 때, 우리 앱의 <span class="emphasize">모든 자바스크립트 파일과 라이브러리</span>를 하나하나 읽어 분석하고, 이걸 <span class="emphasize">하나의 (또는 몇 개의) 큰 파일로 합치는 작업(번들링)</span>을 해요. 프로젝트가 커질수록 이 준비 시간이 점점 길어져서 커피 한 잔 마시고 와야 할 때도 있죠. ☕️</p>
                    <div class="process-flow">
                        <div class="process-step">
                            <span class="icon">🧐</span>
                            <p>모든 코드 스캔 & 전체 번들링</p>
                        </div>
                        <div class="process-step">
                            <span class="icon">⏳</span>
                            <p>개발 서버 시작 (기다림...)</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title icon-text"><span class="icon">🚀</span> Vite의 혁신적인 접근!</h3>
                    <p>Vite는 개발 서버를 시작할 때, <span class="keyword">사전 번들링이 거의 필요 없어요!</span> 대신 브라우저의 <span class="keyword">Native ES Modules (ESM)</span> 기능을 적극 활용해요. 브라우저가 실제로 어떤 코드를 요청하면, 그 때 그 부분만 <span class="emphasize">즉시 변환해서 빠르게 슝~</span> 보내준답니다. 그래서 서버 시작도 순식간이고, 코드 수정 시에도 필요한 부분만 업데이트돼요!</p>
                     <div class="process-flow">
                        <div class="process-step">
                           <span class="icon">💡</span>
                           <p>개발 서버 즉시 시작!</p>
                        </div>
                        <div class="process-step">
                           <span class="icon">🚀</span>
                           <p>브라우저 요청 시 즉시 코드 제공</p>
                        </div>
                    </div>
                </div>

                 <div class="card">
                    <h3 class="card-title icon-text"><span class="icon">🛠️</span> Vite 속도의 두 가지 핵심 기술!</h3>
                    <ul class="benefit-list">
                        <li><strong>Native ESM (ES Modules)</strong>: 최신 브라우저들은 script type="module"을 이해해요. Vite는 이 기능을 사용해서, 전체 코드를 미리 묶지 않고 필요할 때마다 모듈 단위로 바로바로 로드할 수 있게 해줘요.</li>
                        <li><strong>esbuild</strong>: Go 언어로 만들어진 <span class="emphasize">엄청나게 빠른</span> JavaScript 번들러 겸 트랜스파일러예요. Vite는 의존성 사전 번들링이나 TypeScript/JSX 코드를 JavaScript로 변환할 때 이 esbuild를 사용해서 속도를 번개처럼 빠르게 만들어요. ⚡️</li>
                    </ul>
                </div>
            </div>

            <div class="highlight-box">
                <h3 class="card-title icon-text"><span class="icon" style="color: #593C47;">🤔</span> 잠깐, <span class="keyword hand-drawn">Native ESM</span>이 뭐길래?</h3>
                <p>쉽게 말해, 우리가 `import React from 'react'` 처럼 쓰는 ES6 모듈 문법을 <span class="emphasize">브라우저가 직접 이해하고 실행</span>할 수 있다는 뜻이에요! Vite 개발 서버는 이 Native ESM 방식을 사용합니다.</p>
                <p>여러분의 `index.html` 파일에 있는 `<script type="module" src="/src/main.jsx"></script>`를 브라우저가 읽으면, `/src/main.jsx` 파일을 요청해요. 그리고 `main.jsx` 파일 안에 있는 `import App from './App.jsx'` 같은 구문을 만나면, 또다시 `./App.jsx` 파일을 서버에 요청하죠. Vite는 이 요청들을 받아서 필요한 코드만 <span class="emphasize">그때그때 변환</span>해서 보내주는 거예요. 전체 앱을 미리 다 묶어놓을 필요가 없으니 얼마나 효율적이겠어요! 😄</p>
                <div class="code-block">
// public/index.html - 브라우저가 가장 먼저 읽는 파일
<!DOCTYPE html>
<html lang="en">
  <head> <!-- ... --> </head>
  <body>
    <div id="root"></div>
    <!-- 👇 요기! type="module"이 핵심! -->
    <script type="module" src="/src/main.jsx"></script> 
  </body>
</html>

// src/main.jsx - 브라우저가 /src/main.jsx를 서버에 요청
import React from 'react' // 'react' 모듈 요청 (Vite가 처리)
import ReactDOM from 'react-dom/client'
import App from './App.jsx' // './App.jsx' 모듈 요청 (Vite가 처리)
import './index.css'       // './index.css' 모듈 요청 (Vite가 처리)

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
                </div>
            </div>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title icon-text"><span class="icon">🏎️</span> esbuild: <span class="hand-drawn">빛의 속도</span>로 변환!</h3>
                    <p><span class="keyword">esbuild</span>는 Go 언어로 만들어져서, 자바스크립트로 만들어진 기존 도구들(예: Babel)보다 <span class="emphasize">10배에서 많게는 100배까지도 빨라요!</span> Vite는 이 엄청난 친구를 아주 똑똑하게 활용합니다:</p>
                    <ul class="benefit-list">
                        <li><strong>의존성 사전 번들링 (Dependency Pre-bundling):</strong>
                            우리가 `npm install`로 설치하는 외부 라이브러리들 (예: `react`, `lodash` 등)은 대부분 CommonJS나 UMD 형식으로 되어있고, 수많은 작은 모듈로 쪼개져 있을 수 있어요. Vite는 개발 서버 시작 시 <span class="keyword">최초 한 번 (또는 의존성 변경 시)</span> esbuild를 사용해 이들을 Native ESM 형식으로 변환하고, 여러 파일을 하나로 합쳐서 브라우저 요청 횟수를 줄여줘요. 이 과정 덕분에 이후 개발 과정이 매우 쾌적해집니다!
                        </li>
                        <li><strong>TypeScript/JSX 즉석 변환:</strong>
                            React 개발자라면 익숙한 JSX 문법이나 TypeScript 코드를 순수 JavaScript로 변환할 때도 esbuild가 활약해요. 파일 하나하나를 변환하는 속도가 워낙 빨라서 거의 실시간으로 느껴질 정도랍니다!
                        </li>
                    </ul>
                </div>
                <div class="card">
                    <h3 class="card-title icon-text"><span class="icon">📊</span> 그래서 <span class="hand-drawn">얼마나 빠르냐고요?</span> (개발 서버 시작 비교)</h3>
                    <p>프로젝트 규모나 복잡도에 따라 다르지만, Vite는 기존 번들러 방식에 비해 개발 서버 시작 속도와 코드 변경 시 업데이트 속도에서 <span class="emphasize">압도적인 차이</span>를 보여줘요.</p>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th class="vs-webpack-col">Webpack (전통적 번들러)</th>
                                <th class="vs-vite-col">Vite</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>개발 서버 시작 전 작업</strong></td>
                                <td>전체 애플리케이션 번들링 😩 (수십 초 ~ 몇 분)</td>
                                <td>의존성 사전 번들링 (esbuild, 최초 또는 변경 시에만) 후 <strong style="color: #593C47;">즉시 시작!</strong> 😄 (몇 초 이내)</td>
                            </tr>
                            <tr>
                                <td><strong>모듈 로딩 방식</strong></td>
                                <td>번들된 큰 파일 전체 로드</td>
                                <td>브라우저가 Native ESM으로 <strong style="color: #593C47;">필요한 모듈만 요청</strong>하고 즉시 로드</td>
                            </tr>
                             <tr>
                                <td><strong>코드 수정 시 업데이트</strong></td>
                                <td>변경 부분 다시 번들링 (느릴 수 있음)</td>
                                <td>변경된 모듈과 그 영향받는 부분만 <strong style="color: #593C47;">매우 빠르게 교체 (HMR)</strong></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="full-width card" style="background: linear-gradient(135deg, rgba(255,255,255,1) 0%, rgba(242,196,60,0.1) 100%);">
                <h3 class="card-title icon-text"><span class="icon">👩‍💻</span> <span class="hand-drawn">실제 React 프로젝트</span>에서 Vite 경험하기!</h3>
                <p>Vite로 React 프로젝트를 시작하는 건 정말 간단해요. 터미널에 아래 명령어를 입력해보세요:</p>
                <div class="code-block">
# npm 사용 시
npm create vite@latest my-vite-react-app -- --template react-ts 
# yarn 사용 시
# yarn create vite my-vite-react-app --template react-ts
# pnpm 사용 시
# pnpm create vite my-vite-react-app --template react-ts

cd my-vite-react-app
npm install # 또는 yarn install / pnpm install
npm run dev # 또는 yarn dev / pnpm dev
                </div>
                <p>개발 서버가 실행되면 브라우저 개발자 도구의 <span class="keyword">네트워크(Network) 탭</span>을 열어보세요. `main.tsx` (또는 `.jsx`), `App.tsx` 같은 파일들이 개별적으로 로드되는 걸 볼 수 있을 거예요. 이게 바로 <span class="keyword">Native ESM</span> 방식의 증거죠! 반면에 `react`, `react-dom` 같은 외부 라이브러리들은 `node_modules/.vite/deps` 폴더 안에 <span class="emphasize">미리 최적화되어 번들링된 형태</span>로 제공되어 효율성을 높입니다. ✨</p>
                <div class="folder-structure">
my-vite-react-app/
├── node_modules/
│   └── .vite/
│       └── deps/  <-- 🌟 여기에 react, react-dom 등이 최적화되어 저장돼요!
│           └── react.js
│           └── react-dom.js
│           └── ... (다른 의존성들)
├── public/
│   └── vite.svg
├── src/
│   ├── App.css
│   ├── App.tsx     <-- 우리가 작성하는 컴포넌트 파일
│   ├── main.tsx    <-- 앱 진입점
│   ├── index.css
│   └── assets/
│       └── react.svg
├── index.html      <-- <script type="module" src="/src/main.tsx">가 있는 곳!
├── package.json
├── tsconfig.json   <-- (TypeScript 템플릿 사용 시)
└── vite.config.ts  <-- Vite 설정 파일
                </div>
            </div>

            <div class="feedback-section">
                <p>챕터 1 설명은 여기까지입니다! 😊 Vite가 왜 이렇게 <strong class="hand-drawn">빠르고 효율적인지</strong>에 대한 핵심 원리를 이해하는 데 도움이 되셨으면 좋겠네요.</p>
                <p>혹시 <strong class="hand-drawn">더 궁금한 점</strong>이나, "이 부분은 조금 더 자세히 설명해주면 좋겠어요!" 하는 부분이 있다면 언제든지 편하게 말씀해주세요! 🤔 여러분의 피드백은 다음 설명을 더 멋지게 만드는 데 큰 도움이 됩니다! 👍</p>
            </div>
        </section>

        <!-- 챕터 2는 여기에 이어짐 -->

        <footer class="footer">
            <p>Vite.js 핵심 원리 학습 자료 | Crafted by AI Assistant | 날짜: <span id="currentDateFooter"></span></p>
        </footer>
    </div>